
var Main = Main || { };

// called when the gui params change and we need to update mesh
Main.particleSystemChangeCallback = function ( InputSettings ) {

    // Get rid of an old system
    ParticleEngine.stop();
    for ( var i = 0 ; i < ParticleEngine._emitters.length ; ++i ) {
        Scene.removeObject( ParticleEngine.getDrawableParticles( i ) );
    }
    ParticleEngine.removeEmitters();
    ParticleEngine.removeAnimations();

    // Get rid of old models
    Scene.removeObjects();

    // If we specified animated model, then lets load it first
    if ( InputSettings.animatedModelName ) {
        var loader = new THREE.JSONLoader( true );
        loader.load( InputSettings.animatedModelName, InputSettings.animationLoadFunction );
    }

    // Create new system
    var initializer = new InputSettings.initializerFunction ( InputSettings.initializerSettings );
    var updater     = new InputSettings.updaterFunction ( InputSettings.updaterSettings );

    var sphere     = new Emitter( {
        maxParticles:  1,   // how many particles can be generated by this emitter?
        particlesFreq: 20,  // how many particle per second will we emit?
        initialize:    initializer,                  // initializer object
        update:        updater,                      // updater object
        material:      InputSettings.sphereMaterial,
        cloth:         false,
        sphere:        true,
        width:         InputSettings.width,
        height:        InputSettings.height,
        // Radius of particle is in ParticleEngine this._attributeInformation 
        radius:        InputSettings.radius, 
    } );

    // If we are not dealing with cloth, lets sort particles
    if ( !InputSettings.cloth ) {
        sphere.enableSorting( Gui.values.sorting );
    }


    initializer = new InputSettings.initializerFunctionTrail ( InputSettings.initializerSettingsTrail );
    updater     = new InputSettings.updaterFunctionTrail ( InputSettings.updaterSettings );

    var trails     = new Emitter( {
        maxParticles:  2000,   // how many particles can be generated by this emitter?
        particlesFreq: 1000,  // how many particle per second will we emit?
        initialize:    initializer,                  // initializer object
        update:        updater,                      // updater object
        material:      InputSettings.particleMaterial,
        cloth:         false,
        sphere:        false,
        width:         InputSettings.width,
        height:        InputSettings.height,
        // Radius of particle is in ParticleEngine this._attributeInformation 
        // radius:        InputSettings.radius, 
    } );

    // If we are not dealing with cloth, lets sort particles
    if ( !InputSettings.cloth ) {
        trails.enableSorting( Gui.values.sorting );
    }

    ParticleEngine.addEmitter (sphere); 
    ParticleEngine.addEmitter (trails);

    // Add new particle system
    ParticleEngine.start();

    // Add the particle system
    for ( var i = 0 ; i < ParticleEngine._emitters.length ; ++i ) {
        // console.log(ParticleEngine._emitters[i]);
        Scene.addObject( ParticleEngine.getDrawableParticles( i ) ); 
    }

    // Create the scene
    InputSettings.createScene();
};

// when HTML is finished loading, do this
window.onload = function() {
    // Student.updateHTML();
    Score.updateScore(0);

    // Setup renderer, scene and gui
    Gui.init( Main.controlsChangeCallback,
              Main.displayChangeCallback );
    Scene.create();

    // Add particle system
    Main.particleSystemChangeCallback( SystemSettings.mySystem );

    Renderer.create( Scene, document.getElementById("canvas") );
    document.getElementById("canvas").addEventListener("mousedown",  mousedown);
    document.getElementById("canvas").addEventListener("mousemove",  mousemove);
    
    //Interaction.start();

    Renderer.update();
};

// http://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z 
function getCursorPos(event){
    var vector = new THREE.Vector3();

    // for perspective camera
    var camera = Renderer._camera;
    vector.set(
        ( event.clientX / window.innerWidth ) * 2 - 1,
        - ( event.clientY / window.innerHeight ) * 2 + 1,
        0.5 );

    vector.unproject( camera );
    var dir = vector.sub( camera.position ).normalize();
    var distance = - camera.position.z / dir.z;
    var cursor_pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
    return cursor_pos;
}

var plane, neg_plane;
var old_clientX, old_clientY;
var down = false;
var sourceColor = new THREE.Color(0xffffff);
// var destColor = new THREE.Color(0xff0000);

var once = true;
function mousedown(event) {
    console.log("you pressed the mouse button");
    var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );

    var cursor_pos = getCursorPos(event);
    var plane_geo = new THREE.PlaneBufferGeometry(30,30,10,5);
    plane     = new THREE.Mesh( plane_geo, material );
    plane.name = "Trampoline";
    plane.bounce = 1;
    plane.up     = new THREE.Vector3(0, 1, 0);
    neg_plane = new THREE.Mesh( plane_geo, material );
    neg_plane.name = "Trampoline";
    neg_plane.bounce = 1;
    neg_plane.up = new THREE.Vector3(0, -1, 0);
    plane.add(neg_plane);
    // if (once) {
    //     console.log(plane);
    //     once = false;
    // }

    plane.position.x = cursor_pos.x;
    plane.position.y = cursor_pos.y;
    plane.position.z = cursor_pos.z;
    if (plane.position.y > 0) {
        plane.rotation.x = Math.PI/2.0;
        neg_plane.rotation.x = Math.PI;
    }
    else if (plane.position.y <= 0) {
        plane.rotation.x = -Math.PI/2.0;
        neg_plane.rotation.x = -Math.PI;
    }

    old_clientX = event.clientX;
    old_clientY = event.clientY;
    down = true;

    // maybe should be mousemove()
    document.getElementById("canvas").addEventListener("mouseup",  mouseup);
    document.getElementById("canvas").addEventListener("mouseout",  mouseup);

    Scene.addObject(plane);
}

clamp = function(input, min, max) {
    if (input < min) {
        return min;
    } else if (input > max) {
        return max;
    }
    return input;
}

function mousemove(event){
    var timeout = 25;
    if (down){
        setTimeout(function() {
            var norm = new THREE.Vector3(event.clientX - old_clientX, old_clientY - event.clientY , 0);
            plane.bounce = norm.length();
            var maxLength = 400;
            plane.material.color.g = 1-(norm.length() / maxLength);
            plane.material.color.b = 1-(norm.length() / maxLength);

            norm.normalize();
            var theta = Math.acos(plane.up.dot(norm) / (plane.up.length() * norm.length()));

            if (plane.position.y > 0) {
                if (plane.up.clone().cross(norm).z < 0){
                    theta *= -1;
                }
            }
            else if (plane.position.y <= 0) {
                if (plane.up.clone().cross(norm).z > 0){
                    theta *= -1;
                }
            }

            if (!isNaN(theta)){    
                plane.rotation.y += theta;
                plane.up = norm;
            }
        }, timeout);
    }
}

function mouseup(event){
    console.log("you released the mouse button");
    down = false;

    // document.getElementById("canvas").removeEventListener( 'mousemove', mousemove);
    document.getElementById("canvas").removeEventListener( 'mouseup', mouseup);
    document.getElementById("canvas").removeEventListener( 'mouseout', mouseup);
}
